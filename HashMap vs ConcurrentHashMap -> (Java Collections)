=> Both HashMap and ConcurrentHashMap store data as key-value pairs, but the difference lies in concurrency.
â€¢	HashMap: 
   Not thread-safe. 
   If multiple threads modify it concurrently, it may lead to data inconsistency or even infinite loops during resizing. 
   It uses a fail-fast iterator, so modifications while iterating throw ConcurrentModificationException.

â€¢	ConcurrentHashMap: 
   Thread-safe. 
   It achieves this by segmenting the map and using finer-grained locking (per-bucket locking in Java 7, CAS operations in Java 8). 
   It uses a fail-safe iterator, so it doesnâ€™t throw CME, though it may not reflect the very latest changes.

â€¢	Null handling: 
   HashMap allows one null key and multiple null values, whereas ConcurrentHashMap does not allow null keys or null values.

â€¢	Performance: 
   In single-threaded contexts, HashMap is faster. 
   In multi-threaded contexts, ConcurrentHashMap is much safer and more efficient compared to synchronizing a HashMap.

ðŸ”¹When to use what:
    Iâ€™d use HashMap in simple, single-threaded scenarios (like caching inside one request),
    and ConcurrentHashMap when multiple threads need concurrent reads/writes â€” e.g., maintaining a shared in-memory cache in a microservices app

ðŸ”¹ Why ConcurrentHashMap is different from Collections.synchronizedMap(new HashMap())

    o	When you wrap a HashMap with Collections.synchronizedMap(), every method call is synchronized on a single lock (the entire map object).
    o	This means only one thread can read or write at a time, making it thread-safe but very slow under high concurrency.
    o	ConcurrentHashMap, on the other hand, does not lock the entire map for every operation.
    o	Java 7: It divided the map into segments (buckets). Each segment had its own lock. So, multiple threads could safely update different buckets at the same time.
    o	Java 8+: It replaced segmentation with a more efficient scheme:
   	CAS (Compare-And-Swap) for updates (non-blocking).
	  Fine-grained locking only when absolutely necessary (like resizing buckets).
    This means reads are non-blocking and most writes can happen in parallel.

ðŸ”¹Think of a library:
    â€¢	synchronizedMap = locking the whole library door whenever one person wants to borrow a book â†’ only one person at a time.
    â€¢	ConcurrentHashMap = locking only the specific bookshelf youâ€™re using, so many people can borrow books from different shelves at the same time.

