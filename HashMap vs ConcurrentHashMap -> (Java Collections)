=> Both HashMap and ConcurrentHashMap store data as key-value pairs, but the difference lies in concurrency.

â€¢	HashMap: 
   Not thread-safe. 
   If multiple threads modify it concurrently, it may lead to data inconsistency or even infinite loops during resizing. 
   It uses a fail-fast iterator, so modifications while iterating throw ConcurrentModificationException.

â€¢	ConcurrentHashMap: 
   Thread-safe. 
   It achieves this by segmenting the map and using finer-grained locking (per-bucket locking in Java 7, CAS operations in Java 8). 
   It uses a fail-safe iterator, so it doesnâ€™t throw CME, though it may not reflect the very latest changes.

â€¢	Null handling: 
   HashMap allows one null key and multiple null values, whereas ConcurrentHashMap does not allow null keys or null values.

â€¢	Performance: 
   In single-threaded contexts, HashMap is faster. 
   In multi-threaded contexts, ConcurrentHashMap is much safer and more efficient compared to synchronizing a HashMap.

ðŸ”¹When to use what:
    Iâ€™d use HashMap in simple, single-threaded scenarios (like caching inside one request),
    and ConcurrentHashMap when multiple threads need concurrent reads/writes â€” e.g., maintaining a shared in-memory cache in a microservices app

ðŸ”¹ Why ConcurrentHashMap is different from Collections.synchronizedMap(new HashMap())

    o	In Collections.synchronizedMap(new HashMap()) every method call is synchronized on a single lock (the entire map object).
    o	This means only one thread can read or write at a time, making it thread-safe but very slow under high concurrency.
    o	ConcurrentHashMap, on the other hand, does not lock the entire map for every operation.
    o	Java 7: It divided the map into segments (buckets). Each segment had its own lock. So, multiple threads could safely update different buckets at the same time.
    o	Java 8+: It replaced segmentation with a more efficient scheme:
   	CAS (Compare-And-Swap) for updates (non-blocking).
	  Fine-grained locking only when absolutely necessary (like resizing buckets).
    This means reads are non-blocking and most writes can happen in parallel.

ðŸ”¹ In Java 8â€™s ConcurrentHashMap, CAS (Compare-And-Swap) is mainly used during insertions to avoid locking when possible.

If that bucket is empty (null), it tries to insert the new node using CAS.

If CAS succeeds â†’ no locking needed.

If CAS fails (because another thread inserted at the same time), it falls back to synchronized block on that bucket.

Resizing

During table resizing, CAS is used to ensure safe transfer of buckets from old to new table by multiple threads working together.

Updates (compute, putIfAbsent, etc.)

In some operations, CAS is used to atomically update values without locking the entire bucket when contention is low.

âœ… Summary
In ConcurrentHashMap, CAS is mainly used when inserting into an empty bucket â€”
it allows a thread to place the first node lock-free. 
If CAS fails due to contention, it falls back to a synchronized block at the bucket level. 
This combination of CAS and minimal locking makes ConcurrentHashMap much more scalable than a fully synchronized map.

ðŸ”¹Think of a library:
    â€¢	synchronizedMap = locking the whole library door whenever one person wants to borrow a book â†’ only one person at a time.
    â€¢	ConcurrentHashMap = locking only the specific bookshelf youâ€™re using, so many people can borrow books from different shelves at the same time.

