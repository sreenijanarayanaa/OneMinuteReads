=> Both HashMap and ConcurrentHashMap store data as key-value pairs, but the difference lies in concurrency.

â€¢	HashMap: 
   Not thread-safe. 
   If multiple threads modify it concurrently, it may lead to data inconsistency or even infinite loops during resizing. 
   It uses a fail-fast iterator, so modifications while iterating throw ConcurrentModificationException.

â€¢	ConcurrentHashMap: 
   Thread-safe. 
   It achieves this by segmenting the map and using finer-grained locking (per-bucket locking in Java 7, CAS operations in Java 8). 
   It uses a fail-safe iterator, so it doesnâ€™t throw CME, though it may not reflect the very latest changes.

â€¢	Null handling: 
   HashMap allows one null key and multiple null values, whereas ConcurrentHashMap does not allow null keys or null values.

â€¢	Performance: 
   In single-threaded contexts, HashMap is faster. 
   In multi-threaded contexts, ConcurrentHashMap is much safer and more efficient compared to synchronizing a HashMap.

ðŸ”¹Think of a library:
    â€¢	synchronizedMap = locking the whole library door whenever one person wants to borrow a book â†’ only one person at a time.
    â€¢	ConcurrentHashMap = locking only the specific bookshelf youâ€™re using, so many people can borrow books from different shelves at the same time.

ðŸ”¹When to use what:
    Iâ€™d use HashMap in simple, single-threaded scenarios (like caching inside one request),
    and ConcurrentHashMap when multiple threads need concurrent reads/writes â€” e.g., maintaining a shared in-memory cache in a microservices app

ðŸ”¹ Why ConcurrentHashMap is different from Collections.synchronizedMap(new HashMap())

    - In Collections.synchronizedMap(new HashMap()) every method call is synchronized on a single lock (the entire map object).
    - This means only one thread can read or write at a time, making it thread-safe but very slow under high concurrency.
    - In ConcurrentHashMap, when we call put(), it first computes the bucket index.
   		â€¢ If the bucket is empty, it uses CAS(compare and swap) to insert the node lock-free.
		â€¢ If CAS fails, or the bucket is already occupied, it synchronizes only on that bucket and either inserts into the linked list or red-black tree.
		â€¢ If needed, resizing is triggered, where multiple threads can cooperate to transfer entries.

This combination of CAS for empty buckets, bucket-level locking for collisions, and parallel resizing gives ConcurrentHashMap its high scalability in multi-threaded environments.




