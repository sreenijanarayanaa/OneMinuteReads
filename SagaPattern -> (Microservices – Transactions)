To handle a transaction over multiple services, use the SAGA PATTERN. 
Here's how it works: 
Split the main transaction into smaller parts, with each part handled by a different service. 
Each service completes its part and tells the others whether it succeeded or failed. 
If one part fails, other services undo their work to keep everything consistent. 
This way, even though the services are separate, they work together to complete the transaction or back out if thereâ€™s a problem. 

ðŸ‘‰ Suppose in the same e-commerce flow, the order is saved in MySQL but the payment fails. How would you ensure data consistency across services in this case?

In our e-commerce example:
â€¢	The Order Service saves the order in PENDING state and publishes an OrderCreated event.
â€¢	The Payment Service consumes it, processes the payment, and publishes either PaymentSuccess or PaymentFailed.
â€¢	If successful, the Order Service updates the status to CONFIRMED.
â€¢	If failed, instead of rolling back the DB insert, the Order Service triggers a compensating transaction â€” updating the order to CANCELLED.

There are two Saga implementation styles:
â€¢	Choreography: 
Services communicate via events (Kafka, RabbitMQ). Decentralized, simpler, but can get complex with many services.
â€¢	Orchestration: 
A central Saga orchestrator controls the flow. More control, but single point of dependency.

This way, we achieve eventual consistency across services without relying on distributed 2-phase commits.

What is eventual consistency? 
Eventual consistency is a concept used when managing data across different locations in a network.
It means that when data is updated in one place, it might take some time before all parts of the system see the change.
This approach allows the system to run faster and handle more users or actions at once, even though the data might not be exactly the same everywhere right away.
Eventually, all parts of the system will have the updated data.
