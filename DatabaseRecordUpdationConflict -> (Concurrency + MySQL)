üëâ Suppose two users try to update the same order record in MySQL at the same time. How would you handle this concurrency problem to ensure data consistency?

When two users try to update the same order record concurrently, 
we need to ensure consistency using transaction isolation and locking mechanisms:

‚Ä¢	Optimistic Locking: We add a version field to the Order entity (using @Version in JPA). 
 Each update checks the version ‚Äî if another user has updated the row, it will throw an OptimisticLockException. 
 The application can then retry or inform the user. This is efficient when conflicts are rare.

‚Ä¢	Pessimistic Locking: We explicitly lock the record during a transaction using @Lock(LockModeType.PESSIMISTIC_WRITE) in JPA.
 This prevents other transactions from updating it until the current one finishes. Useful when conflicts are frequent.

‚Ä¢	Isolation Levels: MySQL also allows adjusting transaction isolation (READ COMMITTED, REPEATABLE READ, SERIALIZABLE) 
 depending on the level of consistency required versus performance.

In real-world Spring Boot applications, I‚Äôd typically start with optimistic locking (lighter, scalable), and switch to pessimistic locking only if conflicts are high

üîπ Transaction Isolation Levels in MySQL
1. READ UNCOMMITTED

Lowest isolation.

Transactions can see uncommitted changes from other transactions.

‚úÖ Allows dirty reads.

‚ùå Not commonly used because data can be inconsistent.

2. READ COMMITTED

Each SELECT sees only data committed at the moment the query runs.

‚úÖ Prevents dirty reads.

‚ùå Still allows:

Non-repeatable reads ‚Üí same row read twice in the same transaction may show different values.

Phantom reads ‚Üí new rows may appear if another transaction inserts matching rows.

3. REPEATABLE READ (‚ö° Default in MySQL/InnoDB)

Ensures that all reads within a transaction are consistent (even if another transaction modifies the data later).

‚úÖ Prevents dirty reads and non-repeatable reads.

‚ùå Still allows phantom reads (but MySQL‚Äôs Next-Key Locking often prevents them in practice).

4. SERIALIZABLE

Highest isolation level.

Transactions are executed as if sequentially (one after another).

‚úÖ Prevents dirty reads, non-repeatable reads, phantom reads.

‚ùå Very costly (locks more rows, reduces concurrency).
